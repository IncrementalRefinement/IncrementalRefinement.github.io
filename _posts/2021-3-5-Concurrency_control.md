# <center>Concurrency Control</center>

## Basic Conceps

这一部分用来理清一下自己之前认识的模糊部分，列出&强调之前存在的认识误区

### Hardware supprots

锁能实现原子性需要硬件/CPU的支持，硬件额外实现了原子性的指令/操作，比如Compare-And-Swap、Fetch-And-Add等，否则光通过软件来实现所只会将问题不断递归(锁--》锁的锁--》锁的锁的锁)永远不能解决问题，硬件实现了这些原子指令，然后OS在这些指令的基础上实现了这些同步机制

### Spin Locks (自旋锁)

依靠硬件提供的支持指令，自旋锁很容易就能被设计出，其基本形式是一个while循环，while一直尝试获取锁，获取锁成功就从循环break，进行下一步操作

当然，如果一直尝试获取锁，那么就会处于一个busy waiting的状态，线程被分配到的时间片上的这种busy waiting显然是在浪费CPU的计算资源，于是一种优化是获取锁失败之后在while循环中主动yield，希望下一次被分配到时间片时锁能够被获取，但这样做依然是处于一个不断询问的过程，依然会有进入内核态以及从内核态退出的overhead，离理想的状态依然相差甚远

虽然自旋锁存在各种的问题，那么难道完全没有可取之处了吗？那其实是有的，在CPU资源充足的情况下使用自旋锁可以大大提高反应时间，比如有两个线程在两个CPU(核心)上，一个获取了锁，一个不断waiting等待锁的释放，一旦释放就几乎能立即反应。当然，虽然有这种特殊情况，但实在过于罕见，所以自旋锁的应用并不广泛

### Mutex ()

为了解决这个问题，就有了mutex，mutex希望做到这一点：如果线程获取mutex失败就进入阻塞状态，当mutex被释放的时候再将所有等待该mutex的线程全部唤醒或者从中选择一个唤醒，然后一个线程就能获得锁并进行运行。这就将主动的不断询问转换为被动的等待，更加高效，但也需要内核提供相应的支持(这一部分看一下xv6源码了解一下)

### Condition Variable (条件变量)

我认为CV的采用主要是要解决这种类型的问题：比如一个线程在获得一个int后，判断int是否大于10,然后根据判断结果再判断是否进行后续操作；另一个线程不断更新int的值，这显然是需要保护临界区的。在int变为10之前，判断的线程就会不断重复获得锁、解锁这个状态，带来大量开销，所以用条件变量和mutex结合来更高效地实现这个过程。通过cond_wait, cond_signal的过程来等待条件变量上的信号以及发送信号(具体实现还是要看一下源码，我好菜....)

条件变量通常要和互斥锁相配合，防止对CV的signal信号丢失，具体丢失的情景不在这里赘述，想一下就行

### semaphore (信号量)

semaphore由DJ提出，具体规则不在这里赘述，既能由semaphore来实现mutex、CV，也能由mutex、CV实现信号量，我个人认为semephore将资源抽象为信号量的初始值，在很多场景下更为方便(比如消费者-生产者问题使用semaphore就非常方便)

### And what is R/W lock?

读写锁的产生我认为主要是因为读写锁这种一个exclusive一个shared的锁的情况非常常见，所以系统提供了这个接口，而不是要用户反复造轮子

读写锁可以由两个mutex实现，一个mutex用于保护读的数量，一个mutex用作写锁，在此不赘述

## Producer&Consumer problem

下次补上，今天写得有点累
